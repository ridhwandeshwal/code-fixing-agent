import re
import os
import google.generativeai as genai
from tools.validate import validate_patch
from tools.extract_code import extract_code
from tools.write_temp import write_patch
from tools.llm_call import generate_fix
from tools.context_extract import extract_context
from config import GEMINI_API_KEY, MAX_RETRIES


genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel("gemini-1.5-flash")

TOOL_REGISTRY = {
    "validate_patch": validate_patch,
    "extract_code": extract_code,
    "write_patch": write_patch,
    "generate_fix": generate_fix,
    "extract_context": extract_context
}

import re
def parse_tool_call(output: str, context_vars: dict):
    match = re.search(r"TOOL_CALL:\s*(\w+)\((.*)\)", output.strip(), re.DOTALL)
    if not match:
        raise ValueError("Invalid tool call format from Gemini")

    tool_name, args_str = match.groups()

    arg_pairs = re.findall(r"(\w+)\s*=\s*'((?:[^'\\]|\\.)*)'", args_str, re.DOTALL)

    kwargs = {}
    for key, raw_val in arg_pairs:
        val = bytes(raw_val, "utf-8").decode("unicode_escape")
        kwargs[key] = val

    return tool_name, kwargs



def agent_loop(initial_task: str, context_vars: dict):
    context = initial_task
    count=MAX_RETRIES
    while True:
        prompt = f"""
You are an agent controller. Based on the task, decide which tool to use, one tool at a time.

Current Task:
{context}

Context Variables:
{context_vars}

Available Tools:
- extract_context(program_name: str) -> (code, error)
- generate_fix(code: str, error: str) -> llm_output
- extract_code(llm_output: str) -> str
- write_patch(program_name: str, code: str) -> str
- validate_patch(program_name: str) -> "pass" | "fail"

Respond only in format:
TOOL_CALL: tool_name(arg1, arg2, ...)
"""
        response = model.generate_content(prompt)
        print("REPOSNSEE:", response)
        lines = response.text.strip().splitlines()
        tool_line = next((line for line in lines if line.strip().startswith("TOOL_CALL:")), None)
        if not tool_line:
            raise ValueError("No TOOL_CALL found in Gemini response.")

        tool_name, kwargs = parse_tool_call(tool_line, context_vars)

        required_params = TOOL_REGISTRY[tool_name].__code__.co_varnames
        for param in required_params:
            if param not in kwargs and param in context_vars:
                kwargs[param] = context_vars[param]

        print(f"ðŸš€ Calling tool: {tool_name}({', '.join(repr(a) for a in kwargs)})")
        result = TOOL_REGISTRY[tool_name](**kwargs)


        print(f" {tool_name} returned: {result}\n")

        if tool_name == "extract_context":
            context_vars["code"], context_vars["error"] = result
        elif tool_name == "generate_fix":
            context_vars["llm_output"] = result
        elif tool_name == "extract_code":
            context_vars["code"] = result
        elif tool_name == "write_patch":
            context_vars["patch_path"] = result
        elif tool_name == "validate_patch" and result == "pass":
            print(" Patch validated successfully! Exiting loop.")
            break
        elif tool_name == "validate_patch" and result == "fail":
            if count == 0:
                print(" Unsuccessful changes. Max retries reached.")
                break
            else:
                print(f" Retry attempt. {count} tries left.")
                context += f"\nNote: The previous patch generated by the model failed validation. Retrying with a different fix."
                count -= 1

        context += f"\nLast result from {tool_name}: {result}"
        

if __name__ == "__main__":
    task = "Fix the buggy function using the LLM output, write it to a temp file, and then validate it."
    context_vars = {
        "program_name": "kheapsort"
    }
    agent_loop(task, context_vars)
